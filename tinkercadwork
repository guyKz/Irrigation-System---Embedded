

#include <avr/io.h>
#include <avr/interrupt.h>
#include <avr/wdt.h>
#include <LiquidCrystal.h>
#include <Servo.h>

 
// HARDWARE CONFIGURATION


// ADC Channel Definitions
#define MOISTURE_1_CH    0    // Analog pin A0 - Zone 1 moisture sensor
#define MOISTURE_2_CH    1    // Analog pin A1 - Zone 2 moisture sensor
#define TEMP_SENSOR_CH   2    // Analog pin A2 - TMP36 temperature sensor
#define LIGHT_SENSOR_CH  3    // Analog pin A3 - Light sensor (photoresistor)

// Digital Pin Definitions
#define SERVO_PIN        9    // PWM pin for servo motor (water valve)
// Note: PORTB pins are used for pump, LED, and buzzer
// PB0 (Pin 8)  - Buzzer
// PB2 (Pin 10) - Water pump relay(LED)
// PB5 (Pin 13) - Status LED

// LCD and Servo Objects
LiquidCrystal lcd(7, 6, 5, 4, 3, 2);  // RS, E, D4, D5, D6, D7
Servo waterValve;                      // Servo motor for water valve control

// 
// GLOBAL VARIABLES - SENSOR DATA
// 

volatile uint16_t moisture1 = 0;       // Zone 1 moisture level (0-100%)
volatile uint16_t moisture2 = 0;       // Zone 2 moisture level (0-100%)
volatile uint16_t avgMoisture = 50;    // Average moisture level (0-100%)
volatile int16_t temperature = 25;     // Temperature in Celsius (-40 to 125)
volatile uint16_t lightLevel = 50;     // Light level (0-100%)
volatile uint8_t waterLevel = 100;     // Water tank level (0-100%)

// 
// GLOBAL VARIABLES - SYSTEM STATE
// 

volatile bool pumpStatus = false;           // Pump on/off state
volatile uint16_t irrigationCycles = 0;     // Total number of irrigation cycles
volatile uint16_t systemSeconds = 0;        // System uptime in seconds
volatile uint16_t lastIrrigationStop = 0;   // Time when pump last stopped
volatile uint8_t currentPumpDuration = 0;   // Current pump run duration (seconds)

// 
// GLOBAL VARIABLES - CONFIGURATION PARAMETERS
// 

uint8_t moistureThreshold = 40;   // Moisture level to trigger irrigation (%)
uint8_t pumpDuration = 5;         // How long pump runs per cycle (seconds)
uint8_t cooldownPeriod = 10;      // Minimum time between cycles (seconds)

// 
// GLOBAL VARIABLES - ISR FLAGS & COUNTERS
// 

volatile uint8_t isrFlags = 0;              // Bit flags for ISR events
#define FLAG_ONE_SECOND  (1<<0)             // Bit 0: 1 second has elapsed
#define FLAG_ADC_UPDATE  (1<<1)             // Bit 1: Time to read sensors

volatile uint8_t timer2OverflowCount = 0;   // Counter for Timer2 overflows (61 = 1s)
volatile uint16_t lcdUpdateCounter = 0;     // Counter for LCD updates (3s)
volatile uint16_t wdtResetCounter = 0;      // Counter for watchdog resets (1s)
volatile uint8_t lcdScreen = 0;             // Current LCD screen (0 or 1)

// 
// HARDWARE INITIALIZATION
// 

/*
  Sets pins as outputs and ensures they start in OFF state
 */
void initPorts() {
    // Configure pins as outputs
    DDRB |= (1<<DDB0) | (1<<DDB2) | (1<<DDB5);
    // DDB0 (Pin 8)  - Buzzer output
    // DDB2 (Pin 10) - Pump relay output
    // DDB5 (Pin 13) - LED output
    
    // Set all outputs to LOW (off)
    PORTB &= ~((1<<PB0) | (1<<PB2) | (1<<PB5));
}

/*
  Initialize ADC (Analog to Digital Converter)
  Configuration:
     Reference voltage: AVCC (5V)
     Prescaler: 128 (125 kHz ADC clock @ 16MHz)
 */
void initADC() {
    ADMUX = (1<<REFS0);                                      // Use AVCC as reference
    ADCSRA = (1<<ADEN) | (1<<ADPS2) | (1<<ADPS1) | (1<<ADPS0); // Enable ADC, prescaler 128
}

/*
     Mode: Normal (overflow)
     Prescaler: 1024
     Overflow frequency: ~61Hz 
     61 overflows = approximately 1 second
 */

void initTimer2() {
    TCCR2A = 0x00;                                // Normal mode
    TCCR2B = (1<<CS22) | (1<<CS21) | (1<<CS20);  // Prescaler 1024
    TIMSK2 = (1<<TOIE2);                          // Enable overflow interrupt
}

/**
     Timeout: ~2 seconds
     Mode: Interrupt mode
     If system hangs, pump turns off automatically
 */
void initWatchdog() {
    cli();                                        // Disable interrupts during setup
    wdt_reset();                                  // Reset watchdog timer
    WDTCSR |= (1<<WDCE) | (1<<WDE);              // Enable configuration change
    WDTCSR = (1<<WDIE) | (1<<WDP2) | (1<<WDP1) | (1<<WDP0); // 2s timeout, interrupt mode
    sei();                                        // Re-enable interrupts
}

// 
// INTERRUPT SERVICE ROUTINES (ISRs)
// 

/*
  Timer2 Overflow Interrupt
  Triggered  61 times per second
  
     Sets flag for sensor reading
     Counts to 1 second
     Updates pump duration counter
     Resets watchdog timer
  
 */
ISR(TIMER2_OVF_vect) {
    // Signal that it's time to read sensors
    isrFlags |= FLAG_ADC_UPDATE;
    
    // Count Timer2 overflows
    timer2OverflowCount++;
    
    // Check if 1 second has elapsed (61 overflows ≈ 1 second)
    if (timer2OverflowCount >= 61) {
        timer2OverflowCount = 0;          // Reset overflow counter
        isrFlags |= FLAG_ONE_SECOND;      // Signal 1-second tasks
        systemSeconds++;                   // Increment system uptime
        lcdUpdateCounter++;                // Increment LCD update counter
        wdtResetCounter++;                 // Increment watchdog reset counter
        
        // Track pump run duration
        if (pumpStatus) {
            currentPumpDuration++;
        }
        
        // Reset watchdog timer every second (prevent timeout)
        if (wdtResetCounter >= 1) {
            wdt_reset();
            wdtResetCounter = 0;
        }
    }
}

/*
  Triggered if system hangs for more than 2 seconds
  
     Immediately turns off pump
     Prevents flooding if system crashes
 */
ISR(WDT_vect) {
    pumpStatus = false;           // Update pump state
    PORTB &= ~(1<<PB2);          // Turn off pump relay (Pin 10)
    wdt_reset();                  // Reset watchdog timer
}

// 
// SENSOR READING FUNCTIONS
// 

/*
  Read a single ADC channel 
  
  channel - ADC channel number (0-7)
  returns Raw ADC value (0-1023)
  
 */
uint16_t readADC(uint8_t channel) {
    ADMUX = (ADMUX & 0xF0) | (channel & 0x0F);  // Select channel, keep reference
    ADCSRA |= (1<<ADSC);                         // Start conversion
    while (ADCSRA & (1<<ADSC));                  // Wait for conversion to complete
    return ADC;                                   // Return 10-bit result
}


void updateSensors() {
    // Read all 4 analog sensors
    uint16_t raw1 = readADC(MOISTURE_1_CH);     // Zone 1 moisture
    uint16_t raw2 = readADC(MOISTURE_2_CH);     // Zone 2 moisture
    uint16_t rawTemp = readADC(TEMP_SENSOR_CH); // Temperature
    uint16_t rawLight = readADC(LIGHT_SENSOR_CH); // Light level
    
    // Convert moisture readings to percentage (inverted: 0=dry, 100=wet)
    // map(value, fromLow, fromHigh, toLow, toHigh)
    moisture1 = constrain(map(raw1, 0, 1023, 100, 0), 0, 100);
    moisture2 = constrain(map(raw2, 0, 1023, 100, 0), 0, 100);
    avgMoisture = (moisture1 + moisture2) / 2;  // Calculate average
    
    // Convert TMP36 reading to Celsius
    // Formula: Temp(°C) = (Input Voltage - 0.5V) / 10mV
    int32_t voltage_mV = ((int32_t)rawTemp * 5000) / 1023; // ADC to millivolts
    temperature = constrain((voltage_mV - 500) / 10, -40, 125);
    
    // Convert light sensor to percentage (0=dark, 100=bright)
    lightLevel = constrain(map(rawLight, 0, 1023, 0, 100), 0, 100);
}

// 
// IRRIGATION CONTROL FUNCTIONS
// 

/*
  Start irrigation cycle
  
     Turns on pump relay
     Opens servo water valve
     Activates status LED
     Beeps buzzer (100ms)
     Logs event to serial
 */
void startIrrigation() {
    if (pumpStatus) return;  // Already running, do nothing
    
    // Update state
    pumpStatus = true;
    currentPumpDuration = 0;
    
    // Turn on hardware
    PORTB |= (1<<PB2) | (1<<PB5);  // Pump relay + LED
    waterValve.write(90);           // Open valve (90 degrees)
    
    // Beep buzzer (short pulse)
    PORTB |= (1<<PB0);
    delay(100);
    PORTB &= ~(1<<PB0);
    
    // Increment cycle counter
    irrigationCycles++;
    
    // Log event
    Serial.println(">>> PUMP ON <<<");
    Serial.print("Moisture: ");
    Serial.print(avgMoisture);
    Serial.print("% | Threshold: ");
    Serial.println(moistureThreshold);
}

/*
 * Stop irrigation cycle
  
     Turns off pump relay
     Closes servo water valve
     Deactivates status LED
     Beeps buzzer (100ms)
     Records stop time
     Logs event to serial
 */
void stopIrrigation() {
    if (!pumpStatus) return;  // Already stopped, do nothing
    
    // Update state
    pumpStatus = false;
    lastIrrigationStop = systemSeconds;  // Record stop time for cooldown
    currentPumpDuration = 0;
    
    // Turn off hardware
    PORTB &= ~((1<<PB2) | (1<<PB5));  // Pump relay + LED
    waterValve.write(0);               // Close valve (0 degrees)
    
    // Beep buzzer (short pulse)
    PORTB |= (1<<PB0);
    delay(100);
    PORTB &= ~(1<<PB0);
    
    // Log event
    Serial.println(">>> PUMP OFF <<<");
    Serial.print("Water Tank: ");
    Serial.println(waterLevel);
}

/*
  Main irrigation control logic
  Called every second from main loop
  
    1. Emergency stop if moisture >= 80%
    2. If pump running: check duration and water level
    3. If pump stopped: check cooldown period
    4. Start pump if moisture < threshold and water available
 */
void controlIrrigation() {
    // EMERGENCY: Stop pump if moisture too high (prevents flooding)
    if (avgMoisture >= 80) {
        if (pumpStatus) {
            Serial.println("!!! EMERGENCY: Moisture too high !!!");
            stopIrrigation();
        }
        return;
    }
    
    // If pump is currently running
    if (pumpStatus) {
        // Check if pump has run long enough
        if (currentPumpDuration >= pumpDuration) {
            stopIrrigation();
        }
        // Check if water tank is running low
        else if (waterLevel < 10) {
            Serial.println("WARNING: Low water!");
            stopIrrigation();
        }
        return;
    }
    
    // If pump is stopped: check if we can start a new cycle
    uint16_t timeSinceStop = systemSeconds - lastIrrigationStop;
    if (timeSinceStop < cooldownPeriod) return;  // Still in cooldown period
    
    // Start pump if moisture is low and water is available
    if (avgMoisture < moistureThreshold && waterLevel >= 10) {
        startIrrigation();
    }
}

/*
 * Simulate water tank level changes
  
  Consumption:
     Pump ON: -2% per second
  
  Refill:
     Pump OFF: +2% every 3 seconds
  
 
 */
void updateWaterLevel() {
    static uint16_t lastUpdate = 0;  // Last consumption update time
    static uint16_t lastRefill = 0;  // Last refill update time
    
    // Water consumption when pump is running
    if (pumpStatus && systemSeconds != lastUpdate) {
        waterLevel = (waterLevel >= 2) ? waterLevel - 2 : 0;  // Drain 2% per second
        lastUpdate = systemSeconds;
    }
    
    // Auto-refill when pump is off (simulated)
    if (!pumpStatus && systemSeconds - lastRefill >= 3) {
        if (waterLevel < 100) {
            waterLevel = min(waterLevel + 2, 100);  // Add 2% every 3 seconds
        }
        lastRefill = systemSeconds;
    }
}

/*
  Called every 10 seconds
  
  Logic:
     If moisture consistently high (>75%): increase threshold, reduce duration
     If moisture consistently low (<55%): decrease threshold, increase duration
  
  This allows the system to adapt to:
     Different soil types
     Seasonal variations
     Sensor drift
 */
void adaptParameters() {
    if (pumpStatus) return;  // Don't adjust while pump is running
    
    static uint16_t lastAdapt = 0;
    if (systemSeconds - lastAdapt < 10) return;  // Run every 10 seconds
    
  	lastAdapt = systemSeconds;
    
    // Moisture too high: pump is running too often or too long
    if (avgMoisture > 75) {
        // Increase threshold (delay next irrigation)
        if (moistureThreshold < 55) {
            moistureThreshold += 2;
            Serial.print("Threshold increased to ");
            Serial.println(moistureThreshold);
        }
        // Reduce pump duration (less water per cycle)
        if (pumpDuration > 3)	{
          		pumpDuration--;
             	Serial.print("Pump Duration decreased to ");
            	Serial.println(pumpDuration);
        	}
    }
    // Moisture too low: pump not running enough or long enough
    else if (avgMoisture < 55) {
        // Decrease threshold (start irrigation sooner)
        if (moistureThreshold > 30) {
            moistureThreshold -= 2;
            Serial.print("Threshold decreased to ");
            Serial.println(moistureThreshold);
        }
        // Increase pump duration (more water per cycle)
      	if (pumpDuration < 10)	{ 
        	pumpDuration++;
          	Serial.print("Pump Duration increased to ");
            Serial.println(pumpDuration);
        }
    }
}

// 
// DISPLAY FUNCTIONS
// 

/*
  Update LCD display
  Alternates between 2 screens every 3 seconds
  
  Screen 0:
    Line 1: Average moisture + Water level
    Line 2: Temperature + Light level
  
  Screen 1:
    Line 1: Zone 1 moisture
    Line 2: Zone 2 moisture
 */
void updateLCD() {
    lcd.clear();
    
    if (lcdScreen == 0) {
        // Screen 0: System overview
        lcd.setCursor(0, 0);
        lcd.print("M:");           // Moisture
        lcd.print(avgMoisture);
        lcd.print("% W:");         // Water
        lcd.print(waterLevel);
        lcd.print("%");
        
        lcd.setCursor(0, 1);
        lcd.print("T:");           // Temperature
        lcd.print(temperature);
        lcd.print("C L:");         // Light
        lcd.print(lightLevel);
        lcd.print("%");
    } else {
        // Screen 1: Detailed zone readings
        lcd.setCursor(0, 0);
        lcd.print("Zone1: ");
        lcd.print(moisture1);
        lcd.print("%");
        
        lcd.setCursor(0, 1);
        lcd.print("Zone2: ");
        lcd.print(moisture2);
        lcd.print("%");
    }
    
    // Toggle to next screen
    lcdScreen = (lcdScreen + 1) % 2;
}

/*
  Send system telemetry as JSON
  Transmitted every second via Serial (9600 baud)
 */
void sendJSON() {
    Serial.print("{\"moist\":");
    Serial.print(avgMoisture);
  	Serial.print(",\"zone1\":");
    Serial.print(moisture1);           
    Serial.print(",\"zone2\":");
    Serial.print(moisture2);    
    Serial.print(",\"temp\":");
    Serial.print(temperature);
    Serial.print(",\"light\":");
    Serial.print(lightLevel);
    Serial.print(",\"pump\":\"");
    Serial.print(pumpStatus ? "ON" : "OFF");
    Serial.print("\",\"servo\":");
    Serial.print(pumpStatus ? 90 : 0);
    Serial.print(",\"led\":\"");
    Serial.print(pumpStatus ? "ON" : "OFF");
    Serial.print("\",\"water\":");
    Serial.print(waterLevel);
    Serial.print(",\"thr\":");
    Serial.print(moistureThreshold);
    Serial.print(",\"cycles\":");
    Serial.print(irrigationCycles);
    Serial.println("}");
}

// 
// MAIN CONTROL LOGIC
// 

/*
  Handle ISR flags and execute corresponding tasks
  This function is called continuously from loop() 
 */
void handleISRFlags() {
    // Check if it's time to read sensors (~every 16ms)
    if (isrFlags & FLAG_ADC_UPDATE) {
        isrFlags &= ~FLAG_ADC_UPDATE;  // Clear flag
        updateSensors();                // Read all 4 sensors (~500µs)
    }
    
    // Check if 1 second has elapsed
    if (isrFlags & FLAG_ONE_SECOND) {
        isrFlags &= ~FLAG_ONE_SECOND;   // Clear flag
        
        // Execute 1-second tasks
        updateWaterLevel();              // Update tank simulation
        controlIrrigation();             // Check if pump needs start/stop
        adaptParameters();               // Adjust thresholds (every 10s)
        
        // Update LCD every 3 seconds
        if (lcdUpdateCounter >= 3) {
            updateLCD();
            lcdUpdateCounter = 0;
        }
        
        // Send telemetry every second
        sendJSON();
    }
}


void setup() {
    cli();  // Disable interrupts during setup
    
    // Initialize serial communication
    Serial.begin(9600);
    
    // Initialize hardware peripherals
    initPorts();    // GPIO pins for pump, LED, buzzer
    initADC();      // Analog to digital converter
    initTimer2();   // System timer (61Hz overflow)
    
    // Initialize LCD and show startup message
    lcd.begin(16, 2);
    lcd.print("Smart Irrigation");
    lcd.setCursor(0, 1);
    lcd.print("Starting...");
    
    // Initialize servo and close valve
    waterValve.attach(SERVO_PIN);
    waterValve.write(0);  // Close valve initially
    
    // Initialize system state
    lastIrrigationStop = 0;  // No previous irrigation
    
    // Initialize watchdog timer (must be last)
    initWatchdog();
    
    sei();  // Enable interrupts - system is now live
    
    // Startup beep (indicates successful initialization)
    PORTB |= (1<<PB0);   // Buzzer ON
    delay(200);
    PORTB &= ~(1<<PB0);  // Buzzer OFF
    
    // Wait 2 seconds, then clear LCD
    delay(2000);
    lcd.clear();
    
    // Print configuration to serial monitor
    Serial.println("=== SMART IRRIGATION ===");
    Serial.println("Threshold: 40%");
    Serial.println("Pump Duration: 5s");
    Serial.println("Cooldown: 10s");
    Serial.println("========================");
    Serial.println("Ready!");
    Serial.println();
}

/*
  
    Checks and handles ISR flags
  triggered by Timer2 ISR 
 */
void loop() {
    handleISRFlags();  // Check flags and execute tasks
    delay(10);
}